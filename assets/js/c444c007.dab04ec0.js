"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[9324],{25520(e,n,s){s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>l});var t=s(74848),i=s(28453);const r={title:"Kubernetes and systemd inspired patterns",status:"backlog",created:new Date("2026-02-26T00:00:00.000Z"),updated:new Date("2026-02-26T00:00:00.000Z")},d=void 0,a={id:"sidebar/development/tasks/backlog/2026-02-26-kubernetes-systemd-patterns",title:"Kubernetes and systemd inspired patterns",description:"Objective",source:"@site/docs/sidebar/development/tasks/backlog/2026-02-26-kubernetes-systemd-patterns.md",sourceDirName:"sidebar/development/tasks/backlog",slug:"/sidebar/development/tasks/backlog/2026-02-26-kubernetes-systemd-patterns",permalink:"/osapi/sidebar/development/tasks/backlog/2026-02-26-kubernetes-systemd-patterns",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Kubernetes and systemd inspired patterns",status:"backlog",created:"2026-02-26T00:00:00.000Z",updated:"2026-02-26T00:00:00.000Z"},sidebar:"testSidebar",previous:{title:"Extract GitHub org config into dedicated repo",permalink:"/osapi/sidebar/development/tasks/backlog/2026-02-25-github-org-config-repo"},next:{title:"Sessions",permalink:"/osapi/category/sessions"}},o={},l=[{value:"Objective",id:"objective",level:2},{value:"Ideas",id:"ideas",level:2},{value:"Node Conditions (Kubernetes-inspired)",id:"node-conditions-kubernetes-inspired",level:3},{value:"Capacity and Allocatable (Kubernetes-inspired)",id:"capacity-and-allocatable-kubernetes-inspired",level:3},{value:"Taints and Tolerations (Kubernetes-inspired)",id:"taints-and-tolerations-kubernetes-inspired",level:3},{value:"Node Lifecycle Events (Kubernetes-inspired)",id:"node-lifecycle-events-kubernetes-inspired",level:3},{value:"Consistent Resource Model (Kubernetes-inspired)",id:"consistent-resource-model-kubernetes-inspired",level:3},{value:"Agent States (systemd-inspired)",id:"agent-states-systemd-inspired",level:3},{value:"Restart Tracking (systemd-inspired)",id:"restart-tracking-systemd-inspired",level:3},{value:"Additional State to Save",id:"additional-state-to-save",level:3},{value:"Notes",id:"notes",level:2}];function c(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"objective",children:"Objective"}),"\n",(0,t.jsxs)(n.p,{children:["Adopt proven patterns from Kubernetes and systemd to make OSAPI's node\nmanagement feel more mature and operationally familiar. These are ideas to\nexplore beyond the initial heartbeat enrichment and ",(0,t.jsx)(n.code,{children:"node list"}),"/",(0,t.jsx)(n.code,{children:"node get"})," work."]}),"\n",(0,t.jsx)(n.h2,{id:"ideas",children:"Ideas"}),"\n",(0,t.jsx)(n.h3,{id:"node-conditions-kubernetes-inspired",children:"Node Conditions (Kubernetes-inspired)"}),"\n",(0,t.jsxs)(n.p,{children:["Kubernetes nodes report conditions like ",(0,t.jsx)(n.code,{children:"MemoryPressure"}),", ",(0,t.jsx)(n.code,{children:"DiskPressure"}),",\n",(0,t.jsx)(n.code,{children:"PIDPressure"}),", and ",(0,t.jsx)(n.code,{children:"NetworkUnavailable"}),". Since the heartbeat already collects\nmemory and load data, we could derive conditions from thresholds:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Memory > 90% used -> ",(0,t.jsx)(n.code,{children:"MemoryPressure: true"})]}),"\n",(0,t.jsxs)(n.li,{children:["Load 1m > 2x CPU count -> ",(0,t.jsx)(n.code,{children:"HighLoad: true"})]}),"\n",(0,t.jsxs)(n.li,{children:["Disk > 90% used -> ",(0,t.jsx)(n.code,{children:"DiskPressure: true"})," (would need disk in heartbeat or a\nperiodic deep scan)"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Conditions would be stored in the KV registration and shown in ",(0,t.jsx)(n.code,{children:"node list"})," /\n",(0,t.jsx)(n.code,{children:"node get"}),'. They give operators a quick "is anything wrong?" signal without\ndigging into raw numbers.']}),"\n",(0,t.jsx)(n.h3,{id:"capacity-and-allocatable-kubernetes-inspired",children:"Capacity and Allocatable (Kubernetes-inspired)"}),"\n",(0,t.jsx)(n.p,{children:"Kubernetes tracks what resources a node has vs. what's available for scheduling.\nWe could track:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"max_jobs"})," (configured) vs. ",(0,t.jsx)(n.code,{children:"active_jobs"})," (current count)"]}),"\n",(0,t.jsxs)(n.li,{children:["Job slot utilization per agent visible in ",(0,t.jsx)(n.code,{children:"node get"})]}),"\n",(0,t.jsx)(n.li,{children:"Could inform smarter job routing (avoid overloaded agents)"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"taints-and-tolerations-kubernetes-inspired",children:"Taints and Tolerations (Kubernetes-inspired)"}),"\n",(0,t.jsx)(n.p,{children:'Kubernetes nodes can be "tainted" to repel workloads unless they explicitly\ntolerate the taint. We already have label-based routing, but taints would add:'}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Mark a node as ",(0,t.jsx)(n.code,{children:"draining"})," or ",(0,t.jsx)(n.code,{children:"maintenance"})," so new jobs avoid it"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"NoSchedule"})," equivalent: agent stays registered but won't receive new jobs"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"NoExecute"})," equivalent: evict running jobs (graceful drain)"]}),"\n",(0,t.jsxs)(n.li,{children:["CLI:\n",(0,t.jsx)(n.code,{children:"osapi node taint --hostname web-01 --key maintenance --effect NoSchedule"})]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"node-lifecycle-events-kubernetes-inspired",children:"Node Lifecycle Events (Kubernetes-inspired)"}),"\n",(0,t.jsx)(n.p,{children:"Kubernetes records lifecycle events per node (Joined, BecameReady,\nBecameNotReady, etc.). We could store agent lifecycle events in a dedicated KV\nbucket:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:'"agent started" with timestamp and version'}),"\n",(0,t.jsx)(n.li,{children:'"agent stopped" (clean shutdown)'}),"\n",(0,t.jsx)(n.li,{children:'"heartbeat missed" (detected by TTL expiry watcher)'}),"\n",(0,t.jsx)(n.li,{children:'"agent restarted" (same hostname re-registers)'}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Visible via ",(0,t.jsx)(n.code,{children:"node get --hostname X"})," or a dedicated ",(0,t.jsx)(n.code,{children:"node events --hostname X"}),"\ncommand."]}),"\n",(0,t.jsx)(n.h3,{id:"consistent-resource-model-kubernetes-inspired",children:"Consistent Resource Model (Kubernetes-inspired)"}),"\n",(0,t.jsxs)(n.p,{children:["Every Kubernetes object has a uniform envelope: ",(0,t.jsx)(n.code,{children:"apiVersion"}),", ",(0,t.jsx)(n.code,{children:"kind"}),", ",(0,t.jsx)(n.code,{children:"metadata"}),"\n(name, namespace, labels, annotations, creationTimestamp, uid), ",(0,t.jsx)(n.code,{children:"spec"}),",\n",(0,t.jsx)(n.code,{children:"status"}),". We could formalize OSAPI resources similarly:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Each resource type (node, job, audit entry) gets a consistent structure"}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"metadata.labels"}),", ",(0,t.jsx)(n.code,{children:"metadata.annotations"}),", ",(0,t.jsx)(n.code,{children:"metadata.createdAt"})," on every\nresource"]}),"\n",(0,t.jsx)(n.li,{children:"Annotations (separate from labels) for non-routing metadata"}),"\n",(0,t.jsx)(n.li,{children:"Enables generic tooling: filtering, sorting, field selectors"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"agent-states-systemd-inspired",children:"Agent States (systemd-inspired)"}),"\n",(0,t.jsx)(n.p,{children:'Systemd units have explicit states: Active, Inactive, Failed, Activating,\nDeactivating. Currently we only have "present in KV = alive". Adding explicit\nstates would enable:'}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Starting"})," - agent is initializing, not yet processing jobs"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Ready"})," - agent is healthy and processing jobs"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Draining"})," - agent is shutting down gracefully, finishing in-flight jobs but\nnot accepting new ones"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Stopped"})," - clean shutdown (deregistered)"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"State transitions would be visible in the registry and in lifecycle events."}),"\n",(0,t.jsx)(n.h3,{id:"restart-tracking-systemd-inspired",children:"Restart Tracking (systemd-inspired)"}),"\n",(0,t.jsx)(n.p,{children:"Systemd tracks restart counts and restart reasons. We could add:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"restart_count"})," - how many times the agent process has started for this\nhostname"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"last_restart_reason"}),' - "clean start", "crash recovery", etc.']}),"\n",(0,t.jsx)(n.li,{children:"Stability signal for fleet health dashboards"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"additional-state-to-save",children:"Additional State to Save"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"First-seen timestamp"})," (",(0,t.jsx)(n.code,{children:"started_at"}),") distinct from last heartbeat\n(",(0,t.jsx)(n.code,{children:"registered_at"}),') for true "AGE" display like ',(0,t.jsx)(n.code,{children:"kubectl get nodes"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Active job count"})," - how busy the agent is right now"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Agent binary version"})," - for fleet version tracking and rolling upgrade\nvisibility"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"OS kernel version"})," - already available from host provider"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"notes",children:"Notes"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"These are incremental improvements that build on the heartbeat enrichment\nwork. Each can be implemented independently."}),"\n",(0,t.jsx)(n.li,{children:"Priority should be driven by operational value: conditions and capacity\ntracking are highest value for fleet operators."}),"\n",(0,t.jsx)(n.li,{children:"Taints and lifecycle events add complexity but enable sophisticated fleet\nmanagement workflows."}),"\n",(0,t.jsx)(n.li,{children:"The consistent resource model is the most ambitious change and would touch the\nmost code, but pays off long-term for tooling and API consistency."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},28453(e,n,s){s.d(n,{R:()=>d,x:()=>a});var t=s(96540);const i={},r=t.createContext(i);function d(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);