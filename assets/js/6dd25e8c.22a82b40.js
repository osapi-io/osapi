"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[4186],{76724(e,n,t){t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var s=t(74848),r=t(28453);const i={title:"Architecture analysis \u2014 REST+NATS vs gRPC",status:"done",created:new Date("2026-02-15T00:00:00.000Z"),updated:new Date("2026-02-15T00:00:00.000Z")},o=void 0,l={id:"sidebar/development/tasks/done/2026-02-15-docs-rest-nats-vs-grpc-analysis",title:"Architecture analysis \u2014 REST+NATS vs gRPC",description:"Objective",source:"@site/docs/sidebar/development/tasks/done/2026-02-15-docs-rest-nats-vs-grpc-analysis.md",sourceDirName:"sidebar/development/tasks/done",slug:"/sidebar/development/tasks/done/2026-02-15-docs-rest-nats-vs-grpc-analysis",permalink:"/osapi/sidebar/development/tasks/done/2026-02-15-docs-rest-nats-vs-grpc-analysis",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Architecture analysis \u2014 REST+NATS vs gRPC",status:"done",created:"2026-02-15T00:00:00.000Z",updated:"2026-02-15T00:00:00.000Z"},sidebar:"testSidebar",previous:{title:"Document feature roadmap with tiered priorities",permalink:"/osapi/sidebar/development/tasks/done/2026-02-15-docs-feature-roadmap"},next:{title:"Update Docusaurus docs for job system migration",permalink:"/osapi/sidebar/development/tasks/done/2026-02-15-docs-update-docusaurus"}},a={},d=[{value:"Objective",id:"objective",level:2},{value:"Recommendation: Keep REST+NATS",id:"recommendation-keep-restnats",level:2},{value:"Why REST is right for the external API",id:"why-rest-is-right-for-the-external-api",level:2},{value:"Why NATS is right for the job system",id:"why-nats-is-right-for-the-job-system",level:2},{value:"What gRPC would give",id:"what-grpc-would-give",level:2},{value:"What gRPC would cost",id:"what-grpc-would-cost",level:2},{value:"Where to focus instead",id:"where-to-focus-instead",level:2},{value:"Comparison",id:"comparison",level:2},{value:"Outcome",id:"outcome",level:2}];function c(e){const n={code:"code",h2:"h2",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"objective",children:"Objective"}),"\n",(0,s.jsx)(n.p,{children:"Evaluate whether osapi should keep its current REST+NATS architecture or switch\nto gRPC. The goal: a clean, easy-to-extend API for turning stock Linux servers\ninto appliances \u2014 configuring firmware, NTP, RAID, DNS, etc. \u2014 without being\nAnsible."}),"\n",(0,s.jsx)(n.h2,{id:"recommendation-keep-restnats",children:"Recommendation: Keep REST+NATS"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Short answer"}),": Keep the architecture. REST+NATS is the right choice for this\nproblem. gRPC would solve fewer problems than it creates."]}),"\n",(0,s.jsx)(n.h2,{id:"why-rest-is-right-for-the-external-api",children:"Why REST is right for the external API"}),"\n",(0,s.jsx)(n.p,{children:"Users are ops engineers and automation scripts, not microservices. REST gives\nthem:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"curl/httpie/wget"})," \u2014 debug and explore with tools already on every server"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Browser-based tools"})," \u2014 Swagger UI, Postman, any HTTP client"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"OpenAPI codegen"})," \u2014 generate Go, Python, Rust, TypeScript clients from the\nsame spec"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Idempotent semantics"}),' \u2014 PUT/DELETE map naturally to "ensure this state"\nwhich is exactly the appliance config model']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"No client library required"})," \u2014 any language with HTTP support works"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:'gRPC would require every consumer to install protoc tooling, generate stubs, and\nuse a gRPC client library. For a tool whose audience is "drop onto a Linux\nserver and configure it," that\'s a significant barrier.'}),"\n",(0,s.jsx)(n.p,{children:"The OpenAPI-first approach is a strength, not a liability. The contract is\ndefined, server and client are generated, and documentation comes for free. With\ngRPC the same would be done with proto files \u2014 it's not simpler, just different."}),"\n",(0,s.jsx)(n.h2,{id:"why-nats-is-right-for-the-job-system",children:"Why NATS is right for the job system"}),"\n",(0,s.jsx)(n.p,{children:"The job system solves real problems that gRPC doesn't address:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Async operations"})," \u2014 Firmware updates, RAID rebuilds, and package installs\ntake minutes. REST returns 202 + job ID, client polls for status. With gRPC\nthe same pattern would need to be built (or use streaming, which is more\ncomplex)."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Fan-out routing"})," \u2014 The ",(0,s.jsx)(n.code,{children:"_any"})," / ",(0,s.jsx)(n.code,{children:"_all"})," / ",(0,s.jsx)(n.code,{children:"{hostname}"})," subject routing is\nelegant. One API call targets a single host, load-balances across available\nworkers, or broadcasts to a fleet. gRPC has no equivalent \u2014 a routing layer\nwould need to be built on top."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Durability"})," \u2014 JetStream gives persistent queues, replay, and exactly-once\ndelivery. If a worker crashes mid-firmware-update, the job survives in KV.\ngRPC streams are ephemeral \u2014 a queue (like... NATS) would need to be bolted\non for durability."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Audit trail"})," \u2014 Append-only status events\n(",(0,s.jsx)(n.code,{children:"status.{job-id}.{event}.{hostname}.{nano}"}),') give a complete history of\nevery operation. This matters for appliance management (compliance, debugging\n"who changed DNS at 3am").']}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Decoupled privilege model"})," \u2014 The API server runs unprivileged; the worker\nruns with the privileges needed for system changes. NATS is the boundary.\nWith gRPC, a different privilege separation mechanism would be needed."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"what-grpc-would-give",children:"What gRPC would give"}),"\n",(0,s.jsx)(n.p,{children:"The honest benefits of gRPC for this project:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Streaming"})," \u2014 Server-push for real-time job status instead of polling. Nice\nbut not essential. SSE on the REST API achieves the same with less complexity."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Strongly typed contracts"})," \u2014 Already have this via OpenAPI + codegen. Proto\nfiles are not meaningfully stronger than OpenAPI 3.x for this use case."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Performance"}),' \u2014 Binary protobuf encoding is faster than JSON. But the\nbottleneck is "run a shell command to configure RAID" not "serialize a\n200-byte JSON payload."']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Bidirectional streaming"})," \u2014 Useful for log tailing or real-time monitoring.\nBut NATS subjects already give pub/sub for this."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"None of these justify a rewrite."}),"\n",(0,s.jsx)(n.h2,{id:"what-grpc-would-cost",children:"What gRPC would cost"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Rewrite the API layer \u2014 all handlers, middleware, auth, error mapping"}),"\n",(0,s.jsx)(n.li,{children:"Rewrite the CLI client \u2014 from HTTP calls to gRPC stubs"}),"\n",(0,s.jsx)(n.li,{children:"Lose curl-ability \u2014 the primary debugging and exploration tool disappears\n(grpcurl exists but is clunky)"}),"\n",(0,s.jsx)(n.li,{children:"Lose OpenAPI ecosystem \u2014 documentation, client generation for non-Go\nlanguages, Swagger UI"}),"\n",(0,s.jsx)(n.li,{children:'Still need async \u2014 gRPC doesn\'t solve the "firmware update takes 10 minutes"\nproblem. NATS would still be needed, or a job queue in gRPC streaming would\nneed to be built (reinventing what already exists, worse)'}),"\n",(0,s.jsx)(n.li,{children:"Protoc toolchain \u2014 additional build dependency for code generation"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"where-to-focus-instead",children:"Where to focus instead"}),"\n",(0,s.jsx)(n.p,{children:"Rather than a rewrite, invest in:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Complete the job migration (Phase 3-6)"})," \u2014 The current task-to-job\nmigration is the right trajectory. The job system with KV-first storage,\nappend-only events, and subject routing is well-designed. Finish it."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Add SSE or WebSocket for real-time status"})," \u2014 If polling feels clunky for\nlong-running jobs, add a streaming endpoint. This gives gRPC's main UX\nadvantage without abandoning REST."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Expand the provider surface"})," \u2014 The provider pattern (",(0,s.jsx)(n.code,{children:"internal/provider/"}),")\nis the extensibility model. Adding new system capabilities (NTP, RAID,\nfirmware, packages) is purely additive \u2014 new provider implementations, new\nOpenAPI paths, new job operation types. The architecture supports this\ncleanly."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Consider gRPC only for inter-service communication"})," \u2014 If multiple Go\nservices on the same host later need to talk to each other (e.g., a\nmonitoring agent talking to the config agent), gRPC makes sense there. But\nkeep REST as the external API."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"comparison",children:"Comparison"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Concern"}),(0,s.jsx)(n.th,{children:"REST+NATS"}),(0,s.jsx)(n.th,{children:"gRPC"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Ops-friendly debugging"}),(0,s.jsx)(n.td,{children:"curl, browser, Swagger"}),(0,s.jsx)(n.td,{children:"grpcurl (clunky)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Client generation"}),(0,s.jsx)(n.td,{children:"OpenAPI -> any language"}),(0,s.jsx)(n.td,{children:"Proto -> any language"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Async job processing"}),(0,s.jsx)(n.td,{children:"NATS JetStream (built)"}),(0,s.jsx)(n.td,{children:"Must build or bolt on"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Fan-out/routing"}),(0,s.jsx)(n.td,{children:"Subject hierarchy (built)"}),(0,s.jsx)(n.td,{children:"Must build"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Durability"}),(0,s.jsx)(n.td,{children:"KV + streams (built)"}),(0,s.jsx)(n.td,{children:"Must build"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Real-time push"}),(0,s.jsx)(n.td,{children:"Add SSE (incremental)"}),(0,s.jsx)(n.td,{children:"Streaming (native)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Privilege separation"}),(0,s.jsx)(n.td,{children:"API/Worker via NATS"}),(0,s.jsx)(n.td,{children:"Must architect"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Performance"}),(0,s.jsx)(n.td,{children:"Fine for system config"}),(0,s.jsx)(n.td,{children:"Overkill for system config"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Migration cost"}),(0,s.jsx)(n.td,{children:"Zero (keep going)"}),(0,s.jsx)(n.td,{children:"Full rewrite"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"outcome",children:"Outcome"}),"\n",(0,s.jsxs)(n.p,{children:["Decision: ",(0,s.jsx)(n.strong,{children:"Keep REST+NATS."})," The architecture is sound. Ship features, not\nrewrites. gRPC may be considered later for inter-service communication only."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},28453(e,n,t){t.d(n,{R:()=>o,x:()=>l});var s=t(96540);const r={},i=s.createContext(r);function o(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);