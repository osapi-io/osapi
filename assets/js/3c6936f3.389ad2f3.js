"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[1211],{46658(e,n,s){s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>d});var t=s(74848),a=s(28453);const o={title:"Add consistent host targeting to all CLI commands",status:"done",created:new Date("2026-02-17T00:00:00.000Z"),updated:new Date("2026-02-17T00:00:00.000Z")},r=void 0,i={id:"sidebar/development/tasks/done/2026-02-17-feat-cli-consistent-host-targeting",title:"Add consistent host targeting to all CLI commands",description:"Objective",source:"@site/docs/sidebar/development/tasks/done/2026-02-17-feat-cli-consistent-host-targeting.md",sourceDirName:"sidebar/development/tasks/done",slug:"/sidebar/development/tasks/done/2026-02-17-feat-cli-consistent-host-targeting",permalink:"/osapi/sidebar/development/tasks/done/2026-02-17-feat-cli-consistent-host-targeting",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Add consistent host targeting to all CLI commands",status:"done",created:"2026-02-17T00:00:00.000Z",updated:"2026-02-17T00:00:00.000Z"},sidebar:"testSidebar",previous:{title:"API endpoint to list registered NATS workers",permalink:"/osapi/sidebar/development/tasks/done/2026-02-17-feat-api-list-nats-workers"},next:{title:"Label-based worker routing with NATS subject wildcards",permalink:"/osapi/sidebar/development/tasks/done/2026-02-17-feat-label-based-worker-routing"}},l={},d=[{value:"Objective",id:"objective",level:2},{value:"Design",id:"design",level:2},{value:"Approach: <code>--host</code> flag on client subcommand",id:"approach---host-flag-on-client-subcommand",level:3},{value:"Implementation Layers",id:"implementation-layers",level:3},{value:"Layer 1: REST API endpoints accept hostname parameter",id:"layer-1-rest-api-endpoints-accept-hostname-parameter",level:4},{value:"Layer 2: REST client handler interfaces accept hostname",id:"layer-2-rest-client-handler-interfaces-accept-hostname",level:4},{value:"Layer 3: CLI commands pass --host flag value",id:"layer-3-cli-commands-pass---host-flag-value",level:4},{value:"Layer 4: Response formatting for _all",id:"layer-4-response-formatting-for-_all",level:4},{value:"Migration",id:"migration",level:3},{value:"Open Questions",id:"open-questions",level:3},{value:"Notes",id:"notes",level:2}];function c(e){const n={code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"objective",children:"Objective"}),"\n",(0,t.jsxs)(n.p,{children:["The CLI has an inconsistent targeting story. Job commands (",(0,t.jsx)(n.code,{children:"job add"}),", ",(0,t.jsx)(n.code,{children:"job run"}),")\nsupport ",(0,t.jsx)(n.code,{children:"--target-hostname"})," for ",(0,t.jsx)(n.code,{children:"_any"}),"/",(0,t.jsx)(n.code,{children:"_all"}),"/specific host routing. All other\ncommands (",(0,t.jsx)(n.code,{children:"system status"}),", ",(0,t.jsx)(n.code,{children:"network dns get"}),", etc.) have no targeting \u2014 they\nhardcode ",(0,t.jsx)(n.code,{children:"_any"})," through the REST API layer."]}),"\n",(0,t.jsx)(n.p,{children:"This means users cannot:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Query system status from a specific host"}),"\n",(0,t.jsx)(n.li,{children:"Query system status from all hosts"}),"\n",(0,t.jsx)(n.li,{children:"Run a DNS lookup or ping from a specific host"}),"\n",(0,t.jsx)(n.li,{children:"Run any network operation against all hosts"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The job client already supports all routing modes internally. The gap is purely\nin the CLI/REST API surface."}),"\n",(0,t.jsx)(n.h2,{id:"design",children:"Design"}),"\n",(0,t.jsxs)(n.h3,{id:"approach---host-flag-on-client-subcommand",children:["Approach: ",(0,t.jsx)(n.code,{children:"--host"})," flag on client subcommand"]}),"\n",(0,t.jsxs)(n.p,{children:["Add a ",(0,t.jsx)(n.code,{children:"--host"})," persistent flag to the ",(0,t.jsx)(n.code,{children:"client"})," parent command, inherited by all\nsubcommands:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Default: _any (load-balanced, one response)\nosapi client system status\n\n# Target specific host\nosapi client --host server1 system status\n\n# Query all hosts\nosapi client --host _all system status\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This gives consistent behavior across all commands with minimal flag clutter.\nThe ",(0,t.jsx)(n.code,{children:"--host"})," flag would:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Default to ",(0,t.jsx)(n.code,{children:"_any"})," when omitted"]}),"\n",(0,t.jsxs)(n.li,{children:["Accept ",(0,t.jsx)(n.code,{children:"_all"})," for broadcast queries"]}),"\n",(0,t.jsx)(n.li,{children:"Accept any specific hostname"}),"\n",(0,t.jsx)(n.li,{children:"Be inherited by all subcommands automatically"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"implementation-layers",children:"Implementation Layers"}),"\n",(0,t.jsx)(n.h4,{id:"layer-1-rest-api-endpoints-accept-hostname-parameter",children:"Layer 1: REST API endpoints accept hostname parameter"}),"\n",(0,t.jsxs)(n.p,{children:["Add optional ",(0,t.jsx)(n.code,{children:"target_hostname"})," query parameter to REST API endpoints:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"GET /system/status?target_hostname=server1\nGET /system/status?target_hostname=_all\nGET /network/dns/{interface}?target_hostname=server1\nPOST /network/ping?target_hostname=_all\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The API handlers would pass this to the appropriate job client method instead of\nhardcoding ",(0,t.jsx)(n.code,{children:"_any"}),". When ",(0,t.jsx)(n.code,{children:"_all"})," is specified, use the ",(0,t.jsx)(n.code,{children:"QuerySystemStatusAll()"})," /\nbroadcast methods."]}),"\n",(0,t.jsx)(n.h4,{id:"layer-2-rest-client-handler-interfaces-accept-hostname",children:"Layer 2: REST client handler interfaces accept hostname"}),"\n",(0,t.jsxs)(n.p,{children:["Update the ",(0,t.jsx)(n.code,{children:"SystemHandler"})," and ",(0,t.jsx)(n.code,{children:"NetworkHandler"})," interfaces to accept a hostname\nparameter:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"type SystemHandler interface {\n    GetSystemStatus(ctx context.Context, hostname string) (...)\n    GetSystemHostname(ctx context.Context, hostname string) (...)\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"layer-3-cli-commands-pass---host-flag-value",children:"Layer 3: CLI commands pass --host flag value"}),"\n",(0,t.jsxs)(n.p,{children:["Each CLI command reads the ",(0,t.jsx)(n.code,{children:"--host"})," flag from the parent and passes it through:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'host, _ := cmd.Flags().GetString("host")\nresp, err := systemHandler.GetSystemStatus(ctx, host)\n'})}),"\n",(0,t.jsx)(n.h4,{id:"layer-4-response-formatting-for-_all",children:"Layer 4: Response formatting for _all"}),"\n",(0,t.jsxs)(n.p,{children:["When ",(0,t.jsx)(n.code,{children:"--host _all"})," is used, the CLI needs to format multi-host responses. For\nsystem status, this could be a table:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"HOSTNAME    STATUS     UPTIME    LOAD\nserver1     ok         3d 2h     0.5\nserver2     ok         1d 8h     1.2\nserver3     degraded   5d 0h     4.8\n"})}),"\n",(0,t.jsx)(n.h3,{id:"migration",children:"Migration"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"--target-hostname"})," on ",(0,t.jsx)(n.code,{children:"job add"}),"/",(0,t.jsx)(n.code,{children:"job run"})," stays as-is (different semantic \u2014\nraw job targeting)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"--host"})," on ",(0,t.jsx)(n.code,{children:"client"})," is the user-friendly equivalent for high-level commands"]}),"\n",(0,t.jsx)(n.li,{children:"Both use the same routing infrastructure underneath"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"open-questions",children:"Open Questions"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Should ",(0,t.jsx)(n.code,{children:"--host"})," also be configurable via ",(0,t.jsx)(n.code,{children:"osapi.yaml"})," as a default? (e.g.,\n",(0,t.jsx)(n.code,{children:"default_target_host: _any"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:["Should ",(0,t.jsx)(n.code,{children:"_all"})," responses stream as they arrive or wait for timeout?"]}),"\n",(0,t.jsxs)(n.li,{children:["For modify operations with ",(0,t.jsx)(n.code,{children:"_all"})," (e.g., DNS update on all hosts), should we\nrequire explicit confirmation?"]}),"\n",(0,t.jsxs)(n.li,{children:["Should response formatting differ between ",(0,t.jsx)(n.code,{children:"_any"})," (single result) and ",(0,t.jsx)(n.code,{children:"_all"}),"\n(table/list)?"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"notes",children:"Notes"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"publishAndCollect()"})," method and ",(0,t.jsx)(n.code,{children:"QuerySystemStatusAll()"})," are already\nimplemented as of 2026-02-17."]}),"\n",(0,t.jsxs)(n.li,{children:["The REST API ",(0,t.jsx)(n.code,{children:"GET /job/{id}"})," already exposes per-worker ",(0,t.jsx)(n.code,{children:"responses"})," and\n",(0,t.jsx)(n.code,{children:"worker_states"})," for broadcast jobs."]}),"\n",(0,t.jsxs)(n.li,{children:["Each REST API domain (system, network) would need its own ",(0,t.jsx)(n.code,{children:"_all"})," query method\nor a generic pattern."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},28453(e,n,s){s.d(n,{R:()=>r,x:()=>i});var t=s(96540);const a={},o=t.createContext(a);function r(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);