"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[6113],{67150(e,n,s){s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>o,toc:()=>d});var r=s(74848),i=s(28453);const t={title:"Label-based worker routing with NATS subject wildcards",status:"backlog",created:new Date("2026-02-17T00:00:00.000Z"),updated:new Date("2026-02-17T00:00:00.000Z")},l=void 0,o={id:"sidebar/development/tasks/done/2026-02-17-feat-label-based-worker-routing",title:"Label-based worker routing with NATS subject wildcards",description:"Objective",source:"@site/docs/sidebar/development/tasks/done/2026-02-17-feat-label-based-worker-routing.md",sourceDirName:"sidebar/development/tasks/done",slug:"/sidebar/development/tasks/done/2026-02-17-feat-label-based-worker-routing",permalink:"/osapi/sidebar/development/tasks/done/2026-02-17-feat-label-based-worker-routing",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Label-based worker routing with NATS subject wildcards",status:"backlog",created:"2026-02-17T00:00:00.000Z",updated:"2026-02-17T00:00:00.000Z"},sidebar:"testSidebar",previous:{title:"Add consistent host targeting to all CLI commands",permalink:"/osapi/sidebar/development/tasks/done/2026-02-17-feat-cli-consistent-host-targeting"},next:{title:"Complete API input validation hardening",permalink:"/osapi/sidebar/development/tasks/done/2026-02-17-fix-api-input-validation-hardening"}},a={},d=[{value:"Objective",id:"objective",level:2},{value:"Problem",id:"problem",level:2},{value:"Proposed Architecture: Labels as Subject Segments",id:"proposed-architecture-labels-as-subject-segments",level:2},{value:"Core idea",id:"core-idea",level:3},{value:"Subject format",id:"subject-format",level:3},{value:"Worker config",id:"worker-config",level:3},{value:"Worker subscription behavior",id:"worker-subscription-behavior",level:3},{value:"Client targeting",id:"client-targeting",level:3},{value:"Why labels over hierarchical hostnames",id:"why-labels-over-hierarchical-hostnames",level:3},{value:"Why not a registration/discovery service",id:"why-not-a-registrationdiscovery-service",level:3},{value:"Implementation Plan",id:"implementation-plan",level:2},{value:"1. Config changes",id:"1-config-changes",level:3},{value:"2. Subject routing",id:"2-subject-routing",level:3},{value:"3. Worker subscriptions",id:"3-worker-subscriptions",level:3},{value:"4. Stream subjects",id:"4-stream-subjects",level:3},{value:"5. Client-side targeting",id:"5-client-side-targeting",level:3},{value:"6. API changes",id:"6-api-changes",level:3},{value:"7. Worker discovery",id:"7-worker-discovery",level:3},{value:"Migration",id:"migration",level:2},{value:"Future Enhancements (out of scope)",id:"future-enhancements-out-of-scope",level:2},{value:"Notes",id:"notes",level:2}];function c(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"objective",children:"Objective"}),"\n",(0,r.jsxs)(n.p,{children:["Extend worker targeting beyond ",(0,r.jsx)(n.code,{children:"_any"}),", ",(0,r.jsx)(n.code,{children:"_all"}),", and exact hostname. Admins need\nto target groups of servers (e.g., all web servers, all prod machines, all\nservers in rack-3). The solution should leverage NATS native subject wildcards\nfor zero-overhead routing."]}),"\n",(0,r.jsx)(n.h2,{id:"problem",children:"Problem"}),"\n",(0,r.jsxs)(n.p,{children:["Today the ",(0,r.jsx)(n.code,{children:"--target"})," flag accepts only:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"_any"})," \u2014 load-balanced to one random worker"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"_all"})," \u2014 broadcast to every worker"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"server1"})," \u2014 direct to a specific hostname"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:'There is no way to say "all web servers" or "every prod machine in us-east-1."'}),"\n",(0,r.jsx)(n.h2,{id:"proposed-architecture-labels-as-subject-segments",children:"Proposed Architecture: Labels as Subject Segments"}),"\n",(0,r.jsx)(n.h3,{id:"core-idea",children:"Core idea"}),"\n",(0,r.jsxs)(n.p,{children:["Workers publish their identity through the subjects they subscribe to. Instead\nof a flat ",(0,r.jsx)(n.code,{children:"jobs.{type}.{hostname}"}),", add label segments that NATS wildcards can\nmatch against."]}),"\n",(0,r.jsx)(n.h3,{id:"subject-format",children:"Subject format"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"jobs.{type}.host.{hostname}     \u2014 direct to specific host\njobs.{type}.label.{key}.{value} \u2014 all hosts with that label\njobs.{type}._any                \u2014 any worker (load-balanced)\njobs.{type}._all                \u2014 broadcast all workers\n"})}),"\n",(0,r.jsx)(n.p,{children:"Examples:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"jobs.query.host.web-prod-01\njobs.query.label.role.web\njobs.query.label.env.prod\njobs.query.label.rack.us-east-1a\njobs.modify.label.role.db\n"})}),"\n",(0,r.jsx)(n.h3,{id:"worker-config",children:"Worker config"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"job:\n  worker:\n    hostname: web-prod-01 # optional, auto-detected if empty\n    labels: # NEW\n      role: web\n      env: prod\n      rack: us-east-1a\n"})}),"\n",(0,r.jsx)(n.h3,{id:"worker-subscription-behavior",children:"Worker subscription behavior"}),"\n",(0,r.jsx)(n.p,{children:"On startup, a worker with the above config subscribes to:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'# Existing patterns\njobs.*.host.web-prod-01          \u2014 direct messages\njobs.*._any                      \u2014 load-balanced (queue group)\njobs.*._all                      \u2014 broadcasts\n\n# NEW: one subscription per label\njobs.*.label.role.web            \u2014 all "role=web" jobs\njobs.*.label.env.prod            \u2014 all "env=prod" jobs\njobs.*.label.rack.us-east-1a    \u2014 all "rack=us-east-1a" jobs\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Label subscriptions use ",(0,r.jsx)(n.strong,{children:"no queue group"})," so every matching worker gets the\nmessage (broadcast semantics within the label group). If the admin wants\nload-balanced label routing (send to one web server, not all), they could use a\nqueue group per label \u2014 but that's a future enhancement."]}),"\n",(0,r.jsx)(n.h3,{id:"client-targeting",children:"Client targeting"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"--target"})," flag (and ",(0,r.jsx)(n.code,{children:"target_hostname"})," query param) expands:"]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Target value"}),(0,r.jsx)(n.th,{children:"Resolves to subject"}),(0,r.jsx)(n.th,{children:"Semantics"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"_any"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"jobs.{type}._any"})}),(0,r.jsx)(n.td,{children:"Load-balanced"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"_all"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"jobs.{type}._all"})}),(0,r.jsx)(n.td,{children:"Broadcast all"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"web-prod-01"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"jobs.{type}.host.web-prod-01"})}),(0,r.jsx)(n.td,{children:"Direct to host"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"role:web"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"jobs.{type}.label.role.web"})}),(0,r.jsx)(n.td,{children:"Broadcast to label"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"env:prod"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"jobs.{type}.label.env.prod"})}),(0,r.jsx)(n.td,{children:"Broadcast to label"})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"key:value"})," syntax is unambiguous \u2014 hostnames cannot contain ",(0,r.jsx)(n.code,{children:":"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"why-labels-over-hierarchical-hostnames",children:"Why labels over hierarchical hostnames"}),"\n",(0,r.jsxs)(n.p,{children:["Hierarchical hostnames (",(0,r.jsx)(n.code,{children:"prod.web.server1"}),") force a single taxonomy. A server\ncan only be in one hierarchy. Labels are multi-dimensional \u2014 a server can be\n",(0,r.jsx)(n.code,{children:"role:web"})," AND ",(0,r.jsx)(n.code,{children:"env:prod"})," AND ",(0,r.jsx)(n.code,{children:"rack:us-east-1a"})," simultaneously. The admin can\ntarget any dimension without restructuring naming conventions."]}),"\n",(0,r.jsx)(n.h3,{id:"why-not-a-registrationdiscovery-service",children:"Why not a registration/discovery service"}),"\n",(0,r.jsx)(n.p,{children:"NATS subject routing IS the discovery mechanism. Workers self-register by\nsubscribing to their label subjects. No external registry, no heartbeats, no\nconsistency problem. If a worker is running, its subscriptions are active. If it\ndies, NATS removes the subscriptions. This is the simplest architecture that\ncould possibly work."}),"\n",(0,r.jsx)(n.h2,{id:"implementation-plan",children:"Implementation Plan"}),"\n",(0,r.jsx)(n.h3,{id:"1-config-changes",children:"1. Config changes"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"File:"})," ",(0,r.jsx)(n.code,{children:"internal/config/types.go"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'type JobWorker struct {\n    // ... existing fields ...\n    Labels map[string]string `mapstructure:"labels"` // NEW\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"2-subject-routing",children:"2. Subject routing"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"File:"})," ",(0,r.jsx)(n.code,{children:"internal/job/subjects.go"})]}),"\n",(0,r.jsx)(n.p,{children:"Add:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'func BuildLabelSubject(key, value string) string {\n    return fmt.Sprintf("jobs.*.label.%s.%s", key, value)\n}\n\nfunc BuildHostSubject(hostname string) string {\n    return fmt.Sprintf("jobs.*.host.%s", hostname)\n}\n\nfunc ParseTarget(target string) (subjectType, key, value string) {\n    // "_any" \u2192 ("_any", "", "")\n    // "_all" \u2192 ("_all", "", "")\n    // "role:web" \u2192 ("label", "role", "web")\n    // "server1" \u2192 ("host", "server1", "")\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Validation:"})," Label keys and values must be ",(0,r.jsx)(n.code,{children:"[a-zA-Z0-9_-]+"})," (NATS subject\ntoken safe). Reject dots, spaces, wildcards."]}),"\n",(0,r.jsx)(n.h3,{id:"3-worker-subscriptions",children:"3. Worker subscriptions"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"File:"})," ",(0,r.jsx)(n.code,{children:"internal/job/worker/consumer.go"})]}),"\n",(0,r.jsxs)(n.p,{children:["Extend consumer creation to loop over ",(0,r.jsx)(n.code,{children:"w.appConfig.Job.Worker.Labels"})," and create\na consumer + goroutine for each ",(0,r.jsx)(n.code,{children:"label.{key}.{value}"})," pattern."]}),"\n",(0,r.jsx)(n.h3,{id:"4-stream-subjects",children:"4. Stream subjects"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"File:"})," Config / stream setup"]}),"\n",(0,r.jsx)(n.p,{children:"Update JetStream stream subjects to include the new patterns:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"jobs.query.>\njobs.modify.>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:">"})," wildcard already covers any depth, so this should already work if the\nstream is configured with ",(0,r.jsx)(n.code,{children:"jobs.>"})," or similar. Verify the current\n",(0,r.jsx)(n.code,{children:"StreamSubjects"})," config value."]}),"\n",(0,r.jsx)(n.h3,{id:"5-client-side-targeting",children:"5. Client-side targeting"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"File:"})," ",(0,r.jsx)(n.code,{children:"internal/job/client/query.go"}),", ",(0,r.jsx)(n.code,{children:"modify.go"})]}),"\n",(0,r.jsxs)(n.p,{children:["Update ",(0,r.jsx)(n.code,{children:"BuildQuerySubject"})," / ",(0,r.jsx)(n.code,{children:"BuildModifySubject"})," calls to parse the target and\nbuild the correct subject. The ",(0,r.jsx)(n.code,{children:"publishAndCollect"})," method already handles\nmulti-response collection, so label targeting works like ",(0,r.jsx)(n.code,{children:"_all"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"File:"})," ",(0,r.jsx)(n.code,{children:"cmd/"})," CLI files"]}),"\n",(0,r.jsxs)(n.p,{children:["Update ",(0,r.jsx)(n.code,{children:"--target"})," flag help text and validation."]}),"\n",(0,r.jsx)(n.h3,{id:"6-api-changes",children:"6. API changes"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"File:"})," OpenAPI specs"]}),"\n",(0,r.jsxs)(n.p,{children:["Update ",(0,r.jsx)(n.code,{children:"target_hostname"})," parameter description and validation to accept\n",(0,r.jsx)(n.code,{children:"key:value"})," label syntax. Consider renaming to ",(0,r.jsx)(n.code,{children:"target"})," in a future version."]}),"\n",(0,r.jsx)(n.h3,{id:"7-worker-discovery",children:"7. Worker discovery"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"File:"})," ",(0,r.jsx)(n.code,{children:"internal/job/client/query.go"})," \u2014 ",(0,r.jsx)(n.code,{children:"ListWorkers"})]}),"\n",(0,r.jsx)(n.p,{children:"Extend worker discovery to optionally filter by label. When listing workers,\neach worker's response should include its labels so the admin can see the\ntopology."}),"\n",(0,r.jsx)(n.h2,{id:"migration",children:"Migration"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Backwards compatible:"})," Existing configs with no ",(0,r.jsx)(n.code,{children:"labels"})," key work\nunchanged. The bare hostname targeting becomes ",(0,r.jsx)(n.code,{children:"host.{hostname}"})," internally\nbut the ",(0,r.jsx)(n.code,{children:"--target server1"})," syntax stays the same."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Stream subjects:"})," If currently ",(0,r.jsx)(n.code,{children:"jobs.query.*"})," (single token wildcard), must\nwiden to ",(0,r.jsx)(n.code,{children:"jobs.query.>"})," (multi-token). This is a one-time migration on stream\nrecreation."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"future-enhancements-out-of-scope",children:"Future Enhancements (out of scope)"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Multi-label targeting:"})," ",(0,r.jsx)(n.code,{children:"role:web,env:prod"})," (AND semantics \u2014 requires\nclient-side intersection of results)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Load-balanced label routing:"})," ",(0,r.jsx)(n.code,{children:"role:web:any"})," to pick one web server (queue\ngroup per label)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Label wildcards:"})," ",(0,r.jsx)(n.code,{children:"env:*"})," to target all environments"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Admin CLI for label management:"}),"\n",(0,r.jsx)(n.code,{children:"osapi admin workers list --label role:web"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Dynamic label registration:"})," Workers can update labels at runtime via NATS"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"notes",children:"Notes"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["NATS subject tokens cannot contain ",(0,r.jsx)(n.code,{children:"."})," so label values like ",(0,r.jsx)(n.code,{children:"us-east-1"})," are\nfine but ",(0,r.jsx)(n.code,{children:"us.east.1"})," would break subject parsing. Use hyphens or underscores."]}),"\n",(0,r.jsx)(n.li,{children:"Label-based subscriptions scale linearly with the number of unique labels per\nworker. A worker with 5 labels creates 5 additional consumers. This is well\nwithin NATS limits."}),"\n",(0,r.jsxs)(n.li,{children:["Consider documenting recommended label taxonomies: ",(0,r.jsx)(n.code,{children:"role"}),", ",(0,r.jsx)(n.code,{children:"env"}),", ",(0,r.jsx)(n.code,{children:"region"}),",\n",(0,r.jsx)(n.code,{children:"rack"}),", ",(0,r.jsx)(n.code,{children:"team"}),"."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},28453(e,n,s){s.d(n,{R:()=>l,x:()=>o});var r=s(96540);const i={},t=r.createContext(i);function l(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);