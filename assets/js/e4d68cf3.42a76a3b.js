"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[456],{88403(e,n,r){r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>c,metadata:()=>i,toc:()=>d});var t=r(74848),s=r(28453);const c={title:"Standardize server/worker CLI lifecycle and context handling",status:"done",created:new Date("2026-02-15T00:00:00.000Z"),updated:new Date("2026-02-18T00:00:00.000Z")},o=void 0,i={id:"sidebar/development/tasks/done/2026-02-15-refactor-server-lifecycle-consistency",title:"Standardize server/worker CLI lifecycle and context handling",description:"Objective",source:"@site/docs/sidebar/development/tasks/done/2026-02-15-refactor-server-lifecycle-consistency.md",sourceDirName:"sidebar/development/tasks/done",slug:"/sidebar/development/tasks/done/2026-02-15-refactor-server-lifecycle-consistency",permalink:"/osapi/sidebar/development/tasks/done/2026-02-15-refactor-server-lifecycle-consistency",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Standardize server/worker CLI lifecycle and context handling",status:"done",created:"2026-02-15T00:00:00.000Z",updated:"2026-02-18T00:00:00.000Z"},sidebar:"testSidebar",previous:{title:"Fix operation naming inconsistencies",permalink:"/osapi/sidebar/development/tasks/done/2026-02-15-refactor-operation-naming"},next:{title:"Port system API to use job client",permalink:"/osapi/sidebar/development/tasks/done/2026-02-15-refactor-system-api-job-client"}},l={},d=[{value:"Objective",id:"objective",level:2},{value:"Current Inconsistencies",id:"current-inconsistencies",level:2},{value:"Desired State",id:"desired-state",level:2},{value:"Proposed Interface",id:"proposed-interface",level:3},{value:"Proposed Helper",id:"proposed-helper",level:3},{value:"Scope",id:"scope",level:2},{value:"Notes",id:"notes",level:2},{value:"Outcome",id:"outcome",level:2}];function a(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"objective",children:"Objective"}),"\n",(0,t.jsx)(n.p,{children:"Standardize how the CLI powers all server-type commands (API server, job worker,\nand any future NATS-based servers) so they operate consistently with context\ncreation, signal handling, start/stop, and graceful termination."}),"\n",(0,t.jsx)(n.p,{children:"Currently the API server and job worker use different lifecycle patterns:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"API server"})," (",(0,t.jsx)(n.code,{children:"cmd/api_server_start.go"}),"): Non-blocking ",(0,t.jsx)(n.code,{children:"Start()"}),", manual\n",(0,t.jsx)(n.code,{children:"<-ctx.Done()"})," block, explicit ",(0,t.jsx)(n.code,{children:"Stop(shutdownCtx)"})," with 10s timeout, manual\nNATS connection cleanup in the command."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Job worker"})," (",(0,t.jsx)(n.code,{children:"cmd/job_worker_start.go"}),"): Blocking ",(0,t.jsx)(n.code,{children:"Start(ctx)"})," that runs\nuntil context cancellation, no explicit Stop method, internal WaitGroup\ncleanup, no shutdown timeout."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"current-inconsistencies",children:"Current Inconsistencies"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Start semantics"}),": API server ",(0,t.jsx)(n.code,{children:"Start()"})," is non-blocking (spawns goroutine),\nworker ",(0,t.jsx)(n.code,{children:"Start(ctx)"})," is blocking (runs until ctx.Done)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Shutdown method"}),": API server requires explicit ",(0,t.jsx)(n.code,{children:"Stop(ctx)"})," call, worker\nrelies solely on context cancellation."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Timeout handling"}),": API server creates a 10s shutdown timeout context,\nworker has no shutdown timeout at all."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Resource cleanup"}),": API server manually closes NATS connection in the\ncommand, worker handles cleanup internally."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Signal flow"}),": Different patterns make it harder to reason about shutdown\nordering."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"desired-state",children:"Desired State"}),"\n",(0,t.jsx)(n.p,{children:"All server-type commands should follow a single, consistent pattern:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["CLI creates context from ",(0,t.jsx)(n.code,{children:"cmd.Context()"})," (already provided by root.go signal\nhandler)"]}),"\n",(0,t.jsx)(n.li,{children:"All servers/workers implement the same lifecycle interface"}),"\n",(0,t.jsx)(n.li,{children:"Graceful shutdown with configurable timeout applied uniformly"}),"\n",(0,t.jsx)(n.li,{children:"Resource cleanup (NATS connections, KV buckets) handled consistently"}),"\n",(0,t.jsxs)(n.li,{children:["A shared ",(0,t.jsx)(n.code,{children:"RunServer"})," or similar helper in ",(0,t.jsx)(n.code,{children:"cmd/"})," that encapsulates the\nstart-block-stop pattern so each command just wires up its dependencies"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"proposed-interface",children:"Proposed Interface"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"// Lifecycle represents a long-running server or worker.\ntype Lifecycle interface {\n    Start() error\n    Stop(ctx context.Context) error\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Or alternatively, the blocking context pattern:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:"// Runner represents a long-running process driven by context.\ntype Runner interface {\n    Run(ctx context.Context) error  // blocks until ctx.Done, handles cleanup\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"proposed-helper",children:"Proposed Helper"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'func runServer(ctx context.Context, server Lifecycle, cleanupFns ...func()) {\n    if err := server.Start(); err != nil {\n        logFatal("failed to start", err)\n    }\n    <-ctx.Done()\n    shutdownCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n    defer cancel()\n    server.Stop(shutdownCtx)\n    for _, fn := range cleanupFns {\n        fn()\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"scope",children:"Scope"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"cmd/api_server_start.go"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"cmd/job_worker_start.go"})}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"internal/api/server.go"})," (ServerManager interface + implementation)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"internal/job/worker/server.go"})," (Worker lifecycle)"]}),"\n",(0,t.jsx)(n.li,{children:"Any future server commands"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"notes",children:"Notes"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Root context and signal handling in ",(0,t.jsx)(n.code,{children:"cmd/root.go"})," is already good \u2014 signals\ntrigger ",(0,t.jsx)(n.code,{children:"cancel()"})," which propagates to all commands via ",(0,t.jsx)(n.code,{children:"ExecuteContext(ctx)"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Chose non-blocking ",(0,t.jsx)(n.code,{children:"Start()"})," / ",(0,t.jsx)(n.code,{children:"Stop(ctx)"})," over blocking ",(0,t.jsx)(n.code,{children:"Run(ctx)"})," because\nEcho and the embedded NATS server are inherently non-blocking."]}),"\n",(0,t.jsxs)(n.li,{children:["Shutdown timeout is hardcoded at 10s in ",(0,t.jsx)(n.code,{children:"runServer"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"outcome",children:"Outcome"}),"\n",(0,t.jsxs)(n.p,{children:["All three server commands now use the same ",(0,t.jsx)(n.code,{children:"Lifecycle"})," interface and shared\n",(0,t.jsx)(n.code,{children:"runServer"})," helper in ",(0,t.jsx)(n.code,{children:"cmd/lifecycle.go"}),". The worker was refactored from\nblocking ",(0,t.jsx)(n.code,{children:"Start(ctx)"})," to non-blocking ",(0,t.jsx)(n.code,{children:"Start()"})," + ",(0,t.jsx)(n.code,{children:"Stop(ctx)"})," with a\n",(0,t.jsx)(n.code,{children:"WaitGroup"}),"-based graceful shutdown. NATS connection cleanup was added to the\nworker command (previously missing). The ",(0,t.jsx)(n.code,{children:"ServerManager"})," interface was replaced\nby the shared ",(0,t.jsx)(n.code,{children:"Lifecycle"})," interface."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},28453(e,n,r){r.d(n,{R:()=>o,x:()=>i});var t=r(96540);const s={},c=t.createContext(s);function o(e){const n=t.useContext(c);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(c.Provider,{value:n},e.children)}}}]);