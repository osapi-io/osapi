"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[4564],{28986(e,s,n){n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>d,metadata:()=>r,toc:()=>c});var i=n(74848),t=n(28453);const d={title:"Add server-side pagination to job list",status:"done",created:new Date("2026-02-19T00:00:00.000Z"),updated:new Date("2026-02-19T00:00:00.000Z")},o=void 0,r={id:"sidebar/development/tasks/done/2026-02-19-fix-job-list-pagination",title:"Add server-side pagination to job list",description:"Objective",source:"@site/docs/sidebar/development/tasks/done/2026-02-19-fix-job-list-pagination.md",sourceDirName:"sidebar/development/tasks/done",slug:"/sidebar/development/tasks/done/2026-02-19-fix-job-list-pagination",permalink:"/osapi/sidebar/development/tasks/done/2026-02-19-fix-job-list-pagination",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Add server-side pagination to job list",status:"done",created:"2026-02-19T00:00:00.000Z",updated:"2026-02-19T00:00:00.000Z"},sidebar:"testSidebar",previous:{title:"Add job retry command",permalink:"/osapi/sidebar/development/tasks/done/2026-02-19-feat-job-retry-command"},next:{title:"Surface job IDs in API responses and CLI output",permalink:"/osapi/sidebar/development/tasks/done/2026-02-19-quick-wins-job-id-tracing"}},l={},c=[{value:"Objective",id:"objective",level:2},{value:"Current Behavior",id:"current-behavior",level:2},{value:"Proposed Fix",id:"proposed-fix",level:2},{value:"Phase 1: Server-side limit/offset in ListJobs",id:"phase-1-server-side-limitoffset-in-listjobs",level:3},{value:"Phase 2: Optimize GetJobStatus key scanning",id:"phase-2-optimize-getjobstatus-key-scanning",level:3},{value:"Phase 3: Consider KV bucket separation",id:"phase-3-consider-kv-bucket-separation",level:3},{value:"Out of Scope",id:"out-of-scope",level:2},{value:"Acceptance Criteria",id:"acceptance-criteria",level:2},{value:"Outcome",id:"outcome",level:2},{value:"Changes made",id:"changes-made",level:3}];function a(e){const s={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.h2,{id:"objective",children:"Objective"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"ListJobs"})," fetches every key from NATS KV and then calls ",(0,i.jsx)(s.code,{children:"GetJobStatus"})," for each\none, creating an N+1 query problem. With thousands of jobs this is unacceptably\nslow. Add server-side pagination so only the requested page of jobs is\nprocessed."]}),"\n",(0,i.jsx)(s.h2,{id:"current-behavior",children:"Current Behavior"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"ListJobs"})," calls ",(0,i.jsx)(s.code,{children:"kv.Keys()"})," which returns ALL keys in the bucket"]}),"\n",(0,i.jsxs)(s.li,{children:["For each ",(0,i.jsx)(s.code,{children:"jobs.*"})," key it calls ",(0,i.jsx)(s.code,{children:"GetJobStatus()"}),", which itself calls\n",(0,i.jsx)(s.code,{children:"kv.Keys()"})," again and reads every status event for that job"]}),"\n",(0,i.jsxs)(s.li,{children:["The CLI's ",(0,i.jsx)(s.code,{children:"--limit"})," and ",(0,i.jsx)(s.code,{children:"--offset"})," flags slice the result client-side after\neverything has already been fetched"]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["With N jobs, this is: 1 ",(0,i.jsx)(s.code,{children:"Keys()"})," + N x (1 ",(0,i.jsx)(s.code,{children:"Get"})," + 1 ",(0,i.jsx)(s.code,{children:"Keys"})," + M ",(0,i.jsx)(s.code,{children:"Get"}),"s for status\nevents). At scale this is O(N*M) KV reads."]}),"\n",(0,i.jsx)(s.h2,{id:"proposed-fix",children:"Proposed Fix"}),"\n",(0,i.jsx)(s.h3,{id:"phase-1-server-side-limitoffset-in-listjobs",children:"Phase 1: Server-side limit/offset in ListJobs"}),"\n",(0,i.jsxs)(s.p,{children:["Add ",(0,i.jsx)(s.code,{children:"limit"})," and ",(0,i.jsx)(s.code,{children:"offset"})," parameters to ",(0,i.jsx)(s.code,{children:"ListJobs()"})," so it stops calling\n",(0,i.jsx)(s.code,{children:"GetJobStatus()"})," after collecting enough results. This doesn't fix the initial\n",(0,i.jsx)(s.code,{children:"Keys()"})," call but eliminates the N+1 amplification."]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"internal/job/client/jobs.go"})," \u2014 Add ",(0,i.jsx)(s.code,{children:"limit"}),", ",(0,i.jsx)(s.code,{children:"offset"})," params to ",(0,i.jsx)(s.code,{children:"ListJobs()"}),".\nCount matching ",(0,i.jsx)(s.code,{children:"jobs.*"})," keys, skip ",(0,i.jsx)(s.code,{children:"offset"})," entries, stop after ",(0,i.jsx)(s.code,{children:"limit"}),"\nresults. Return total count alongside results."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"internal/api/job/job_list.go"})," \u2014 Pass limit/offset from query params to\n",(0,i.jsx)(s.code,{children:"ListJobs()"})]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"internal/api/job/gen/api.yaml"})," \u2014 Add ",(0,i.jsx)(s.code,{children:"limit"})," and ",(0,i.jsx)(s.code,{children:"offset"})," query params to the\n",(0,i.jsx)(s.code,{children:"/job"})," endpoint spec"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"internal/client/client.go"})," / CLI \u2014 Pass limit/offset through the client to\nthe API"]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"phase-2-optimize-getjobstatus-key-scanning",children:"Phase 2: Optimize GetJobStatus key scanning"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"GetJobStatus"})," calls ",(0,i.jsx)(s.code,{children:"kv.Keys()"})," to find status events, scanning ALL keys in the\nbucket every time. This is the inner loop of the N+1."]}),"\n",(0,i.jsx)(s.p,{children:"Options:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Prefix-filtered key listing"}),": If NATS KV supports ",(0,i.jsx)(s.code,{children:"KeysFilter"})," or similar,\nuse ",(0,i.jsx)(s.code,{children:"status.{jobID}.*"})," prefix to avoid scanning unrelated keys"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Denormalized status field"}),": Store computed status directly on the job entry\n(updated on each event write) so ",(0,i.jsx)(s.code,{children:"ListJobs"})," can read status from the job entry\nitself without scanning events"]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"phase-3-consider-kv-bucket-separation",children:"Phase 3: Consider KV bucket separation"}),"\n",(0,i.jsxs)(s.p,{children:["Currently jobs, status events, and responses all share one KV bucket. ",(0,i.jsx)(s.code,{children:"Keys()"}),"\nreturns everything. Separating into dedicated buckets (one for job definitions,\none for status events) would make key scanning much cheaper."]}),"\n",(0,i.jsx)(s.h2,{id:"out-of-scope",children:"Out of Scope"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Cursor-based pagination (would need NATS KV Watch or similar)"}),"\n",(0,i.jsx)(s.li,{children:"Full-text search / filtering beyond status"}),"\n",(0,i.jsx)(s.li,{children:"Database migration (staying with NATS KV)"}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"acceptance-criteria",children:"Acceptance Criteria"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"job list --limit 10"})," only processes 10 jobs server-side"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"job list --limit 10 --offset 20"})," skips 20, processes 10"]}),"\n",(0,i.jsx)(s.li,{children:"Total count is returned for UI summary without processing all jobs"}),"\n",(0,i.jsx)(s.li,{children:"Existing tests updated, no coverage regression"}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"outcome",children:"Outcome"}),"\n",(0,i.jsx)(s.p,{children:"Phase 1 completed. Phase 2 partially addressed (GetQueueStats N+1 fix)."}),"\n",(0,i.jsx)(s.h3,{id:"changes-made",children:"Changes made"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"internal/job/client/types.go"})})," \u2014 Added ",(0,i.jsx)(s.code,{children:"ListJobsResult"})," struct, updated\n",(0,i.jsx)(s.code,{children:"ListJobs"})," signature to accept ",(0,i.jsx)(s.code,{children:"limit"}),"/",(0,i.jsx)(s.code,{children:"offset"})," and return ",(0,i.jsx)(s.code,{children:"*ListJobsResult"})]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"internal/job/client/jobs.go"})})," \u2014 Rewrote ",(0,i.jsx)(s.code,{children:"ListJobs"})," with single ",(0,i.jsx)(s.code,{children:"kv.Keys()"}),"\ncall, newest-first ordering, server-side pagination. Added\n",(0,i.jsx)(s.code,{children:"getJobStatusFromKeys"})," helper that reuses pre-fetched keys. Fixed\n",(0,i.jsx)(s.code,{children:"GetQueueStats"})," N+1 bug (removed redundant inner ",(0,i.jsx)(s.code,{children:"kv.Keys()"}),")."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"internal/api/job/gen/api.yaml"})})," \u2014 Added ",(0,i.jsx)(s.code,{children:"limit"})," and ",(0,i.jsx)(s.code,{children:"offset"})," query params\nto ",(0,i.jsx)(s.code,{children:"GET /job"})]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"internal/api/job/job_list.go"})})," \u2014 Extract limit/offset from request params,\nuse ",(0,i.jsx)(s.code,{children:"result.TotalCount"})," for ",(0,i.jsx)(s.code,{children:"TotalItems"}),". Fixed status validation\n(",(0,i.jsx)(s.code,{children:"unprocessed"})," \u2192 ",(0,i.jsx)(s.code,{children:"submitted"}),")."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"internal/client/job_list.go"})})," \u2014 Added ",(0,i.jsx)(s.code,{children:"limit"}),"/",(0,i.jsx)(s.code,{children:"offset"})," params to\n",(0,i.jsx)(s.code,{children:"GetJobs()"})]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"internal/client/handler.go"})})," \u2014 Updated ",(0,i.jsx)(s.code,{children:"JobHandler"})," interface"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:(0,i.jsx)(s.code,{children:"cmd/client_job_list.go"})})," \u2014 Pass limit/offset to API, removed client-side\nslicing, use ",(0,i.jsx)(s.code,{children:"TotalItems"})," from response"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsxs)(s.strong,{children:[(0,i.jsx)(s.code,{children:"cmd/client_job_{get,delete,list}.go"}),",\n",(0,i.jsx)(s.code,{children:"cmd/client_network_{dns_get,dns_update,ping}.go"}),",\n",(0,i.jsx)(s.code,{children:"cmd/client_system_{hostname_get,status_get}.go"})]})," \u2014 Added missing\n",(0,i.jsx)(s.code,{children:"StatusBadRequest"})," (400) error handling across all CLI commands"]}),"\n",(0,i.jsx)(s.li,{children:"All tests updated, mocks regenerated, all passing"}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},28453(e,s,n){n.d(s,{R:()=>o,x:()=>r});var i=n(96540);const t={},d=i.createContext(t);function o(e){const s=i.useContext(d);return i.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function r(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(d.Provider,{value:s},e.children)}}}]);